% chapter4.tex
% Capitulo 4. Resultados
%==========================================================================
\chapter{Resultados}
\label{ch:resultados}

En este cap\'itulo se muestran los resultados del estudio de la plataforma USRP. El experimento
consisti\'o en transmitir datos generados de una fuente aleatoria por software y de una fuente fija
que consiste en una imagen entre las tarjetas LFTX y LFRX por medio de un cable coaxial. Estos
datos son modulados con el esquema DQPSK como est\'a implementado en \emph{GNURadio}. La version del \emph{software} que se utilizo para el experimento fue la 3.3.0.
Posteriormente se observ\'o los resultados utilizando las herramientas proporcionadas por \gnuradio y el lenguaje \emph{Python}. El c\'odigo base
que se utiliz\'o fueron los programas \emph{benchmark\_tx} y \emph{benchmark\_rx}. Estos programas son parte de los ejemplos que ofrece
el c\'odigo fuente de \emph{GNURadio}. La caracter\'istica principal de estos dos programas es que emplean la gran mayor\'ia de
los conceptos y t\'ecnicas de modulaci\'on que ofrece el sistema, as\'i como tambi\'en ilustra el uso de las herramientas
gr\'aficas que se pueden utilizar para crear interfaces de usuario que permitan formar aplicaciones desde sencillas hasta complejas.

Como su nombre lo indica, estos programas fueron desarrollados por los autores de \gnuradio con el fin de poder evaluar los
conceptos y todas las variantes del USRP. La aplicaci\'on consiste en un transmisor y receptor unidireccional. Ambos programas
tienen acceso a todos los esquemas de modulaci\'on y demodulaci\'on del c\'odigo fuente y el usuario puede elegir a trav\'es de
comandos del programa cual desea utilizar para su aplicaci\'on. Los programas se pueden modificar y tambi\'en se pueden utilizar
como base para desarrollar otras aplicaciones y por lo tanto se eligieron para ilustrar el uso del sistema. 

%Material utilizado
%==========================================================================
\section{Material utilizado}
El material que se utiliz\'o para realizar el experimento fue el siguiente:

\begin{itemize}
  \item 1 USRP
  \item Tarjetas LFTX y LFRX
  \item Cable coaxial con terminales SMA a SMA
  \item Cable USB
  \item Computadora laptop con las siguientes caracter\'isticas:
  \begin {itemize}
    \item CPU Intel Core 2 Duo T5550 a 1.83Ghz
    \item 4GB memoria DDR2
    \item Sistema operativo Ubuntu 10.01
  \end{itemize}
\end{itemize}

Los programas \verb|benchmark_tx.py| y \verb|benchmark_rx.py| de la carpeta de ejemplos del c\'odigo
fuente fueron utilizados para realizar la transmisi\'on, ya que estos ejemplos son programas
completos y maduros que ayudan a ilustrar varias caracter\'isticas de la programaci\'on con
\emph{GNURadio}. Los programas \verb|benckmark_tx2.py| y \verb|benchmark_rx2.py| tienen la misma
estructura que su versi\'on anterior pero estos implementan el modulador y demodulador utilizando la
t\'ecnica de filtros polif\'asicos. Esta versi\'on, incluyendo los bloques que implementan estos
filtros, fueron incluidos en el c\'odigo fuente el 23 de Marzo de 2010 y fueron incluidos en este
estudio para comparar el rendimiento de ambas versiones.

Se opt\'o por utilizar un cable coaxial entre las tarjetas TX y RX para observar el rendimiento del sistema lo mas aproximado
posible a lo te\'orico, es decir, con la menor cantidad de p\'erdidas en la transmisi\'on. La impedancia del cable es de
50$\Omega$ y soporta una frecuencia m\'axima de operaci\'on de 12.4Ghz. Los conectores SMA manejan un rango de frecuencias entre
0 y 18Ghz. La se\~nal viaja entre el conductor central y una capa protectora, com\'unmente aluminio. Este arreglo ofrece una
buena protecci\'on contra el ruido externo \cite{coax}.


%Parametros utilizados
%==========================================================================
\section{Par\'ametros utilizados}
\label{sec:params}

Para ejecutar los ejemplos \verb|benchmark_tx.py| y \verb|benchmark_rx.py| es necesario moverse al
directorio donde se encuentran. La ruta es:
\begin{center}
\verb|<dir_del_codigo_fuente>|/\verb|gnuradio-examples|/\verb|python|/\verb|digital|
\end{center}
Los programas se ejecutan por medio de la consola de texto utilizando la notaci\'on \verb|./| para
indicar que se correr\'a un ejecutable. La sintaxis completa es:
\begin{center}
\verb|./benchmark_tx.py <opciones>|
\end{center}
donde \verb|<opciones>| son configuraciones que se pueden pasar al programa para controlar su
funcionamiento. Para ver todas las opciones que soporta se puede utilizar el siguiente comando:
\begin{center}
\verb|./benchmark_tx.py --help|
\end{center}

Algunos par\'ametros contienen valores por defecto que se pueden utilizar como punto de partida para ajustarlos a la
aplicaci\'on que se est\'a desarrollando. Estos valores propuestos por los autores de \gnuradio dieron resultados positivos para
comprobar el correcto funcionamiento de las diversas funciones del c\'odigo, aunque no siempre ser\'an los adecuados
para todas las aplicaciones pero sirven como una referencia para de ah\'i poder optimizarlos. Esta optimizaci\'on es necesaria para
lograr una transmisi\'on eficiente con la menor cantidad de errores posibles. El an\'alisis matem\'atico para la obtenci\'on de
estos valores est\'a fuera del alcance de este trabajo y se deja como propuesta para una investigaci\'on a futuro. Los valores que
se utilicen dependen del \emph{hardware} (USRP, tarjetas, capacidad de la PC) que se est\'e utilizando para desarrollar la
aplicaci\'on. En la mayor\'ia de los par\'ametros de los diferentes bloques y aplicaciones que se emplearon para el experimento
se utilizaron los valores por defecto ya establecidos y recomendados debido a que dieron buenos resultados y buen rendimiento.
Los resultados se muestran a trav\'es de las secciones de este cap\'itulo.

Las opciones que se utilizaron para el transmisor y receptor son las siguientes:

\section*{TRANSMISOR}
\begin{itemize}
  \item \textbf{-m}: Especifica el modulador que se va a utilizar. La opci\'on que se utiliz\'o fue
  DQPSK y DBPSK. BPSK se utiliz\'o para realizar la comparaci\'on entre ambos esquemas.
  \item \textbf{-r}: Especifica la tasa de bits. Se utilizaron varios valores desde 100kbps hasta
  10kbps. Este valor depende mucho de la PC que se est\'e utilizando ya que valores muy altos
  dependen del rendimiento del CPU.
  \item \textbf{--tx-amplitude}: Especifica la amplitud de la se\~nal generada por el DAC en el
  USRP. Sus valores van de 0 a 1. Se utiliz\'o el valor por defecto de 0.25.
  \item \textbf{--excess-bw}: Especifica el par\'ametro $\alpha$ del filtro acoplador de coseno
  elevado. Su rango de valores es de 0 a 1. Se utilizaron tres valores para el an\'alisis: 0.35,
  0.50 y 0.75.
  \item \textbf{-f}: Especifica la frecuencia con la cual se van a sintonizar las tarjetas
  auxiliares. Para este estudio se utiliz\'o la frecuencia m\'axima que soportan las
  tarjetas LFTX y LFRX que es 30Mhz.
  \item \textbf{-S}: Especifica la cantidad de muestras por s\'imbolo. El valor por defecto es de 2. Se
  observ\'o que se tuvo un mejor rendimiento con un valor de 4.
\end{itemize}

\section*{RECEPTOR}
\begin{itemize}
  \item \verb|-m|: Especifica el demodulador que se va a utilizar. Igual que en el transmisor se
  utiliz\'o DQPSK y DBPSK.
  \item \verb|--gain-mu|: Especifica la ganancia que se utiliza en el lazo de costas para la
  detecci\'on de la fase. Se utiliz\'o un valor de 0.5.
  \item \verb|-f|: Especifica la frecuencia a la que se sintoniza la tarjeta RX. Se utiliz\'o un
  valor de 30Mhz.
  \item \verb|-S|: Especifica la cantidad de muestras por s\'imbolo utilizada en el demodulador.
  Igual que en el transmisor se utiliz\'o un valor de 4.
  \item \verb|-r|: Especifica la tasa de bits. Se utilizaron los mismos valores que en el
  transmisor.
  \item \verb|--excess-bw|: Especifica el par\'ametro $\alpha$ del filtro acoplador de coseno
  elevado. Se utilizaron los mismos valores que en el transmisor.
  \item \verb|--timing-alpha|: Especifica la ganancia del PLL que forma parte del banco de filtros
  polif\'asicos para la sincronizaci\'on del reloj de s\'imbolos. Se utiliz\'o un valor de 10.
  \item \verb|--phase-alpha|: Especifica la ganancia del lazo de costas en la segunda versi\'on
  del demodulador DQPSK. Se utilizo un valor de 0.5.
  \item \verb|--freq-alpha|: Especifica la ganancia del FLL para realizar compensaci\'on de
  frecuencia. Se utiliz\'o un valor de 0.001.
\end{itemize}

Debido a que los dos programas son independientes uno del otro, es necesario igualar algunos par\'ametros para lograr una
transmisi\'on exitosa. Los par\'ametros \verb|-f|, \verb|-S|, \verb|-r| y \verb|--excess-bw| son un ejemplo de estos
par\'ametros. Todos los par\'ametros tienen valores por defecto pero uno de ellos es obligatorio especificar y es el de la
frecuencia de sintonizaci\'on \verb|-f|. Si se ejecutan los programas sin especificar este par\'ametro, aunque se especifiquen
los otros, se marcar\'a un error pidiendo que se especifique la frecuencia de operaci\'on. Los par\'ametros \verb|--timing-alpha|,
\verb|--phase-alpha| y \verb|--freq-alpha| son parte de la segunda versi\'on del modulador DQPSK mientras que el par\'ametro
\verb|gain-mu| pertenece a la primera versi\'on.
%==========================================================================
\section{Tasa de error de bits}

El an\'alisis de la tasa de error de bits (Bit error rate o BER por sus siglas en Ingl\'es) se realiz\'o
para ambos modelos de DQPSK proporcionados por \emph{GNURadio}. El programa que se utiliz\'o fue
basado en un estudio generado y publicado en la p\'agina de \gnuradio sobre una versi\'on mejorada
del modulador GMSK. El programa fue modificado para que pudiera analizar y comparar ambos esquemas
DBPSK y DQPSK en sus dos versiones: costas/MM y filtros polif\'asicos.

La estructura del programa est\'a dividida en 3 etapas. La primera etapa genera una se\~nal de una
fuente de n\'umeros pseudo-aleatorios y despues se modula utilizando el modulador que se va a evaluar.
Los datos arrojados por el modulador son enviados a archivos que se utilizar\'an como la entrada para las
siguientes etapas. El programa define una clase llamada \verb|SigGen| derivada de la clase
\verb|top_block| para definir un grafo de flujo de datos. La estructura del grafo se muestra en la
figura \ref{fig:siggen}.

\begin{figure}[htp]
  \centering
  \vspace{0.3in}
  \begin{tikzpicture}[scale=0.8, transform shape, node distance=0.5cm and 0.4cm]
  	\node (glfsr) [grblock] {\footnotesize{Fuente de n\'umeros pseudo-aleatorios}};
  	\node (limiter) [grblock, right=of glfsr] {\footnotesize{Limitador de datos}}
  	edge [<-, very thick] (glfsr);
  	\node (srcbits) [grblock, below=of limiter] {\footnotesize{src\_bits.dat}}
  	edge [<-, very thick] (limiter);
  	\node (unpacktopack) [grblock, right=of limiter] {\footnotesize{Empaquetado de bits}}
  	edge [<-, very thick] (limiter);
  	\node (newmod) [grblock, above right=of unpacktopack] {\footnotesize{Mod\_Demod \\ Poly}};
  	\draw [->, very thick] (unpacktopack.east) -- ++(0.2,0) |- (newmod);
  	\node (cleanbb) [grblock, right=of newmod] {\footnotesize{limpio\_bb.dat}}
  	edge [<-, very thick] (newmod);
  	\node (oldmod) [grblock, below right=of unpacktopack] {\footnotesize{Mod\_Demod \\ Costas\_MM}};
  	\draw [->, very thick] (unpacktopack.east) -- ++(0.2,0) |- (oldmod);
  	\node (cleanoldbb) [grblock, right=of oldmod] {\footnotesize{limpio\_oldbb.dat}}
  	edge [<-, very thick] (oldmod);
  \end{tikzpicture}
  \vspace{0.3in}
  \caption{Grafo generador de datos modulados para la evaluaci\'on del BER.}
  \label{fig:siggen}
\end{figure}

Los bloques se describen de la siguiente manera:

%TODO: Explicar el metodo Galois para generar numeros pseudo-aleatorios
\begin{itemize}
  \item \textbf{Fuente de n\'umeros pseudo-aleatorios}: El bloque se genera por medio de la clase
  \verb|gr.glfsr_source_b|. Esta clase implementa un registro de desplazamiento con
  retroalimentaci\'on lineal en modo Galois. El sufijo ``b'' indica que el generador entrega valores
  binarios. El par\'ametro que se le especifica es el n\'umero de bits de precisi\'on para generar
  una secuencia de bits de longitud $2^{N-1}$, el cual expresa la m\'axima cantidad de valores
  que puede generar antes de ciclarse \cite{xilinx}. 
  \item \textbf{Limitador de datos}: Este bloque se genera por medio de la clase \verb|gr_head|, el
  cual su funci\'on es tomar una cierta cantidad de valores en su entrada y descartar todo lo
  dem\'as. A esta secuencia de valores se le anexa el valor especial \emph{EOF} (fin de archivo por sus siglas en Ingl\'es) que
  especifica el fin del flujo dentro del grafo. Esto causa que el grafo termine su ejecuci\'on una vez que
  este valor se propague a todos los bloques. Sus par\'ametros son el tipo de datos con el que va a
  trabajar y la cantidad de muestras que va a dejar pasar de su entrada a su salida.
  \item \textbf{Source\_bits.dat, Limpio\_bb.dat y Limpio\_oldbb.dat}: Estos bloques utilizan la
  clase \verb|gr.file_sink| para enviar el flujo de datos a un archivo. En este grafo se generan tres
  archivos para guardar los bits originales y los bits modulados con los dos tipos de moduladores
  de \emph{GNURadio}. Sus par\'ametros son el tipo de datos que se van a escribir y el nombre del
  archivo.
  \item \textbf{Empaquetado de bits}: Este bloque se implementa utilizando la clase \\
  \verb|gr.unpacked_to_packed_bb|. Su funcion es agrupar los bits que entran y formar bytes completos
  en la salida. Estos bytes representan la informaci\'on original.
  \item \textbf{Mod\_Demod Poly y Mod\_Demod Costas\_MM}: Estos bloques representan los moduladores
  que se evaluaron durante el experimento y se implementan con las clases \verb|blks2.dqpsk_mod| y
  \verb|blks2.dqpsk2_mod| respectivamente.
\end{itemize}

El c\'odigo que implementa este grafo se muestra en el listado \ref{ex:siggen}.

\begin{lstlisting}[float, label=ex:siggen, caption={C\'odigo que implementa el grafo
generador de se\~nales.}, breaklines=true]
class SigGen(gr.top_block):
  def __init__(self,num_bits=5000,pn_degree=23,xmit_bt=0.25,samp_per_symbol=8):
    gr.top_block.__init__(self, 'SigGen')
	
	src = gr.glfsr_source_b(pn_degree)
	src_limiter = gr.head(gr.sizeof_char, num_bits)

    bit_packer = gr.unpacked_to_packed_bb(1, gr.GR_MSB_FIRST)
    mod = blks2.dqpsk2_mod(samp_per_symbol, xmit_bt)

    bit_packer_old = gr.unpacked_to_packed_bb(1, gr.GR_MSB_FIRST)
    mod_old = blks2.dqpsk_mod(samp_per_symbol, xmit_bt)

    self.connect(src, src_limiter)
    self.connect(src_limiter, gr.file_sink(gr.sizeof_char, 'src_bits.dat'))
    self.connect(src_limiter, bit_packer, mod, gr.file_sink(gr.sizeof_gr_complex, 'limpio_bb.dat'))
    self.connect(src_limiter, bit_packer_old, mod_old, gr.file_sink(gr.sizeof_gr_complex, 'limpio_old_bb.dat'))
\end{lstlisting}

La segunda etapa toma la se\~nal modulada de los archivos y la pasa a trav\'es de un grafo que
aplica ruido Gaussiano para simular un canal de transmisi\'on AWGN. El grafo se muestra en la figura
\ref{fig:noisegen}.

\begin{figure}[htp]
  \centering
  \vspace{0.3in}
  \begin{tikzpicture}[scale=0.8, transform shape, node distance=15mm and 20mm]
  	\node (sigsource) [grblock] {\footnotesize{Fuente de datos de un archivo}};
  	\node (noisesource) [grblock, below=of sigsource] {\footnotesize{Fuente de ruido}};
  	\node (sum) [op, below right=of sigsource, yshift=1.4cm] {$\sum$};
  	\draw [->, very thick] (sigsource.east) -- ++(1,0) |- (sum);
  	\draw [->, very thick] (noisesource.east) -- ++(1,0) |- (sum);
  	\node (noisesig) [grblock, right=of sum] {\footnotesize{Archivo \\ ruido\_bb.dat}}
  	edge [<-, very thick] (sum);
  	\node (noisedat) [grblock, below=of noisesource] {\footnotesize{Archivo ruido.dat}}
  	edge [<-, very thick] (noisesource);
  \end{tikzpicture}
  \vspace{0.3in}
  \caption{Grafo que simula un canal AWGN}
  \label{fig:noisegen}
\end{figure}

El grafo toma como entrada caracter\'istica el valor de la relaci\'on de energ\'ia de bit a ruido
$E_b/N_0$ que se va a utilizar en el an\'alisis. Los bloques se implementan de la siguiente manera:

\begin{itemize}
  \item \textbf{Fuente de datos de archivo}: Este bloque se implementa con la clase
  \verb|gr.file_source|. Se utiliza para leer el archivo generado del grafo \ref{fig:siggen} que
  contiene los bits modulados.
  \item \textbf{Fuente de ruido}: Este bloque se implementa usando la clase \\
  \verb|gr.noise_source_c|. El prefijo ``c'' indica que trabaja con datos complejos. La clase acepta
  dos par\'ametros de entrada: el tipo de ruido que se quiere generar y la magnitud. El tipo de
  ruido puede ser una de las siguientes constantes:
  \begin{itemize}
    \item \verb|GR_UNIFORM|
    \item \verb|GR_GAUSSIAN|
    \item \verb|GR_LAPLACIAN|
    \item \verb|GR_IMPULSE| 
  \end{itemize}
  Para simular el canal AWGN se utiliz\'o la constante \verb|GR_GAUSSIAN|.
  \item \textbf{Archivo ruido\_bb.dat y Archivo ruido.dat}: Este bloque usa la clase
  \verb|file_sink_c| para guardar los datos complejos que representan la se\~nal mezclada con el
  ruido. El archivo \emph{ruido.dat} guarda los datos que representan el puro ruido sin la se\~nal
  modulada.
\end{itemize}

Para determinar la magnitud del ruido el programa primero calcula la potencia promedio del archivo
que contiene la se\~nal modulada sin ruido, la energ\'ia por bit y la magnitud del ruido. La potencia se calcula utilizando la
siguiente expresi\'on:

\begin{equation}\label{eq:bitpower}
P_{prom}=\frac{1}{N}\sum_{n=1}^{N}{x^2(n)}
\end{equation}

La energ\'ia por bit se calcula a partir de la potencia como se muestra en la siguiente
expresi\'on:

\begin{equation}\label{eq:bitenergy}
E_b=\frac{P_{prom}}{f_b}
\end{equation}
donde $f_b$ es la tasa de bits en bits por segundo.

El listado \ref{ex:powenerprogram} muestra dos funciones en \emph{Python} que calculan estos dos
par\'ametros.

\begin{lstlisting}[float, label=ex:powenerprogram, caption={Funciones en \emph{Python} para calcular la
potencia y la energia promedio de una se\~nal}]
def get_p_avg_watts(fn, is_complex=False):

    f = open(fn)
    d = f.read()
    num_floats = (len(d)/4)
    d = struct.unpack('f'*num_floats, d)
    if is_complex:
        d = d[::2] #toma la parte real
    d_sq = [x*x for x in d]
    return sum(d_sq)/len(d_sq)
    
def get_eb_joules(fn, bits_per_sec, is_complex=False):

    p_avg = get_p_avg_watts(fn, is_complex=is_complex)
    return p_avg / bits_per_sec

\end{lstlisting}

El c\'odigo que implementa el grafo \ref{fig:noisegen} se muestra en el listado \ref{ex:pynoisegen}.

\begin{lstlisting}[float, label=ex:pynoisegen, caption={C\'odigo que implementa el grafo generador
de ruido}, breaklines=true]

class NoiseGen(gr.top_block):
  def __init__(self, ebn0_dB, bits_per_sec, samp_per_sec):
    gr.top_block.__init__(self, 'NoiseGen')

    ebn0_ratio = dB_to_ratio(ebn0_dB)

    n0_watts_per_Hz = bertool.get_eb_joules(fn = 'limpio_bb.dat', bits_per_sec = bits_per_sec) / ebn0_ratio 
    n_mag = sqrt(0.5 * n0_watts_per_Hz * samp_per_sec)
    n_src = gr.noise_source_c(gr.GR_GAUSSIAN, n_mag)
    sig_src = gr.file_source(gr.sizeof_gr_complex, 'limpio_bb.dat')
    adder = gr.add_cc()

    self.connect(sig_src, adder, gr.file_sink(gr.sizeof_gr_complex, 'ruido_bb.dat'))
    self.connect(n_src, (adder, 1))
    self.connect(n_src, gr.file_sink(gr.sizeof_gr_complex, 'ruido.dat'))
\end{lstlisting}

La tercera etapa realiza la demodulaci\'on de las se\~nales capturadas por los grafos anteriores.
Esta etapa consiste en leer la se\~nal mezclada con ruido, aplicar un filtro pasa bajas pre-selector
para seleccionar la porci\'on del canal de inter\'es, demodular la se\~nal recibida y guardar los
datos generados en un archivo para realizar la comparaci\'on. La estructura del grafo que realiza esta
etapa se muestra en la figura \ref{fig:analizer}.

\begin{figure}[htp]
  \centering
  \vspace{0.3in}
  \begin{tikzpicture}[scale=0.8, transform shape]
  	\node (sigsource) [grblock] {\footnotesize{Archivo con se\~nal y ruido}};
  	\node (fir) [grblock, right=of sigsource] {\footnotesize{Filtro pre-selector}}
  	edge [<-, very thick] (sigsource);
  	\node (demod) [grblock, right=of fir] {\footnotesize{Demodulador}}
  	edge [<-, very thick] (fir);
  	\node (sink) [grblock, below=of demod] {\footnotesize{bits\_demod\_bb.dat}}
  	edge [<-, very thick] (demod);
  \end{tikzpicture}
  \vspace{0.3in}
  \caption{Grafo que realiza la demodulaci\'on de la se\~nal simulada}
  \label{fig:analizer}
\end{figure}

El grafo tiene un par\'ametro obligatorio, el demodulador que se va a utilizar para el an\'alisis.
Los dem\'as par\'ametros son opcionales y establecen las de muestras por s\'imbolos, s\'imbolos
por segundo y los par\'ametros de ancho de banda para el filtro pre-selector. Para este an\'alisis
se utilizaron los valores por defecto. Los resultados del filtro se muestran en la figura
\ref{fig:predetect}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.5]{figs/predetectfilter}
  \vspace{0.3in}
  \caption{Respuesta del filtro pre-selector en el receptor para la medici\'on del BER.}
  \label{fig:predetect}
\end{figure}

Los bloques del grafo se implementan de la siguiente manera:

\begin{itemize}
  \item \textbf{Archivo con se\~nal y ruido}: La clase \verb|gr.file_source_c| se encarga de leer el
  archivo generado por el grafo \verb|NoiseGen| para enviarlo al filtro pre-selector.
  \item \textbf{Filtro pre-selector}: El filtro pasa bajas se implementa con una combinacion de dos
  clases: \verb|gr.firdes.low_pass| y \verb|gr.fir_filter_ccf|. La primera se utiliza para generar
  los coeficientes del filtro a partir de los par\'ametros de entrada que se le especifiquen. Se
  utilizaron los valores por defecto del ejemplo a excepci\'on de la ventana. Originalmente utilizaba
  una ventana de tipo Hamming y se cambi\'o a una ventana Kaizer ya que esta tuvo mejor rendimiento y
  ayud\'o a generar una curva de BER m\'as suave. Los par\'ametros que acepta la clase son la
  ganancia, la frecuencia de muestreo, la frecuencia de corte, el ancho de la banda de transici\'on
  y el tipo de ventana. La segunda clase implementa el filtro FIR (Respuesta finita al impulso por sus siglas en Ingl\'es) a
  partir de los coeficientes generados por la clase \verb|gr.firdes.low_pass|. Sus par\'ametros de entrada son el factor de
  decimaci\'on y los coeficientes del filtro.
  \item \textbf{Demodulador}: Este bloque representa el demodulador que se est\'a evaluando. En este
  caso fueron ambos DQPSK y DBPSK en sus dos versiones. Las clases que los implementan se encuentran
  dentro del paquete \verb|blks2|. Su uso se muestra en el listado \ref{ex:mainber}. La clase toma
  la se\~nal filtrada e inicia el proceso de demodulaci\'on y detecci\'on. Los resultados son una serie de bits
  desempaquetados, es decir, bits individuales.
  \item \textbf{Archivo bits\_demod\_bb.dat}: Este bloque usa la clase \verb|gr.file_sink| para
  escribir a un archivo los bits resultantes del bloque demodulador.
\end{itemize}

El c\'odigo que implementa el tercer grafo se muestra en el listado \ref{ex:analizer}.

\begin{lstlisting}[float, label=ex:analizer, caption={C\'odigo que implementa el grafo demodulador
para el analisis del BER.}, breaklines=true]
class Analyser(gr.top_block):
    def __init__(self, bb_src_fn, test_demod, samp_per_sym = 8,
                 sym_per_sec = 1e6, pre_detect_filt_bt = 0.9, filt_transition_ratio = 0.1):
        gr.top_block.__init__(self, 'Analyser')

        self.bb_src_fn = bb_src_fn
        self.samp_per_sym = samp_per_sym
        samp_per_sec = samp_per_sym * sym_per_sec

        bb_src = gr.file_source(gr.sizeof_gr_complex, bb_src_fn)

        pre_detect_filt_bw = sym_per_sec * pre_detect_filt_bt
        pre_detect_filt_taps = gr.firdes.low_pass(1.0, samp_per_sec,
                pre_detect_filt_bw, filt_transition_ratio * samp_per_sec,
                gr.firdes.WIN_KAISER, 4.5)
        pre_detect_filt = gr.fir_filter_ccf(1, pre_detect_filt_taps)
        self.connect(bb_src, pre_detect_filt, test_demod)

        self.test_demod_dst_fn = 'bits_demod_bb.dat'
        self.dst = gr.file_sink(gr.sizeof_char, self.test_demod_dst_fn)
        self.connect(test_demod, self.dst)
\end{lstlisting}

El programa principal inicializa los tres grafos y realiza una serie de pruebas para generar la
grafica del BER. La metodolog\'ia que se sigui\'o fue generar varios valores de $E_b/N_0$, desde
12db hasta 2db en intervalos de 0.5db y ejecutar los tres grafos para generar los resultados. Estos
resultados se van guardando en un arreglo y posteriormente se grafican. Los par\'ametros que se
utilizaron para la simulaci\'on fueron los siguientes:

\begin{itemize}
  \item \textbf{N\'umero de bits}: 20000
  \item \textbf{Muestras por s\'imbolo}: 7
  \item \textbf{S\'imbolos por segundo}: $1e6$
  \item \textbf{Exceso de ancho de banda}: 0.75
\end{itemize}

El c\'odigo del programa principal se muestra en el listado \ref{ex:mainber}. El programa original
se modific\'o para que pueda evaluar ambos esquemas a la vez.

\begin{lstlisting}[float=hp, breaklines=true]
if __name__ == "__main__":
    num_bits = 20000
    samp_per_sym = 7
    sym_per_sec = 1e6
    samp_per_sec = sym_per_sec * samp_per_sym
    print "Samples per second: ", samp_per_sec
    xmit_bt = 0.75
    ebn0s_dB = list(numpy.arange(12.0, 1.999, -0.5))
    recv_bt = 0.9
    recv_filt_transition_ratio = 0.1

    sg = SigGen(num_bits = num_bits, xmit_bt = xmit_bt, samp_per_symbol = samp_per_sym)
    sg.run()
    del sg

    dbpsk2_demod_bers = []
    dqpsk2_demod_bers = []
    dbpsk2_delay = None
    dqpsk2_delay = None

    for ebn0_dB in ebn0s_dB:
        print ebn0_dB
        ng = NoiseGen(ebn0_dB = ebn0_dB, bits_per_sec = sym_per_sec, samp_per_sec = samp_per_sec)
        ng.run()
        del ng

        #========================
        # Analisis de DQPSK
        #========================

        test_dqpsk2_demod = blks2.dqpsk_demod(samples_per_symbol = samp_per_sym, excess_bw = xmit_bt)

        a = Analyser(bb_src_fn = 'noisy_qpsk2_bb.dat', test_demod = test_dqpsk2_demod, samp_per_sym = samp_per_sym,
                     sym_per_sec = sym_per_sec, pre_detect_filt_bt = recv_bt,
                     filt_transition_ratio = recv_filt_transition_ratio)

        a.run()
        a.close()
        del a

        if dqpsk2_delay is None:
            dqpsk2_delay = bertool.get_delay('src_bits.dat', 'test_demod_dst_bits.dat')
        ber_stats = bertool.get_ber_stats('src_bits.dat', 'test_demod_dst_bits.dat', dqpsk2_delay)
        dqpsk2_demod_bers.append(ber_stats[0])
\end{lstlisting}

\begin{lstlisting}[float=hp, label=ex:mainber, caption={C\'odigo \emph{Python} de la rutina principal del
an\'alisis del BER.}, breaklines=true]
        #========================
        # Analisis de DBPSK
        #========================

        test_dbpsk2_demod = blks2.dbpsk_demod(samples_per_symbol = samp_per_sym, excess_bw = xmit_bt)

        a = Analyser(bb_src_fn = 'noisy_bpsk2_bb.dat', test_demod = test_dbpsk2_demod, samp_per_sym = samp_per_sym,
                     sym_per_sec = sym_per_sec, pre_detect_filt_bt = recv_bt,
                     filt_transition_ratio = recv_filt_transition_ratio)

        a.run()
        a.close()
        del a

        if dbpsk2_delay is None:
            dbpsk2_delay = bertool.get_delay('src_bits.dat', 'test_demod_dst_bits.dat')
        ber_stats = bertool.get_ber_stats('src_bits.dat', 'test_demod_dst_bits.dat', dbpsk2_delay)
        dbpsk2_demod_bers.append(ber_stats[0])


    ebn0s_dB.reverse()
    dbpsk2_demod_bers.reverse()
    dqpsk2_demod_bers.reverse()

    fig = p.figure()
    p.title(u'Rendimiento de DQPSK y DBPSK')
    ax = fig.add_subplot(111)
    ax.semilogy(ebn0s_dB, dqpsk2_demod_bers, 'b', label = 'DQPSK')
    ax.hold(True)
    ax.semilogy(ebn0s_dB, dbpsk2_demod_bers, 'r', label = 'DBPSK')
    ax.hold(False)

    ax.yaxis.grid(True, which = 'minor')
    ax.xaxis.grid(True)

    p.legend()

    p.ylabel('BER')
    p.xlabel('Ebn0_dB')
    p.show()
\end{lstlisting}

Los resultados de la primera versi\'on de los esquemas DQPSK y DBPSK se muestran en la figura
\ref{fig:bernormal}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.7]{figs/bernormal}
  \caption{Gr\'afica comparativa del BER para la primera versi\'on de los esquemas DQPSK y DBPSK.}
  \label{fig:bernormal}
\end{figure}

Los resultados muestran el rendimiento entre los dos esquemas de modulaci\'on a diferentes niveles
de SNR. Debido a que DQPSK utiliza dos bits por s\'imbolo tiene m\'as probabilidades de generar
errores a niveles muy altos de ruido. Para poder lograr niveles confiables de transmisi\'on se
requiere m\'as potencia que DBPSK.

La segunda versi\'on de estos esquemas intenta mejorar el BER por medio de la implementaci\'on de
bancos de filtros polif\'asicos. La misma metodolog\'ia se sigui\'o para su an\'alisis y los
resultados se muestran en la figura \ref{fig:berpoly}. Como se puede observar, los filtros
polif\'asicos ofrecen una mejora en el rendimiento de ambos esquemas. A niveles bajos de SNR DQPSK
tiene mayor tolerancia que la versi\'on anterior para generar errores. 

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.7]{figs/berpoly}
  \caption{Gr\'afica comparativa del BER para la segunda versi\'on de los esquemas DQPSK y DBPSK.}
  \label{fig:berpoly}
\end{figure}

Por \'ultimo se gener\'o una simulaci\'on en Matlab utilizando la herramienta \emph{BERTool} para generar un estudio te\'orico y
comparar los resultados con la pr\'actica. La herramienta fue configurada lo m\'as cercano posible a los par\'ametros que se
utilizaron en el experimento. Se generaron dos estudios, uno para DBPSK y otro para DQPSK, con un canal de transmisi\'on AWGN. El
resultado de esta simulaci\'on se muestra en la siguiente figura \ref{fig:berteor}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.455]{figs/berteor}
  \caption{Resultados te\'oricos de la herramienta \emph{BERTool} de Matlab.}
  \label{fig:berteor}
\end{figure}

Al comparar los resultados de la simulaci\'on con los del experimento se observ\'o que a menor $E_bN_0$ los algoritmos de
\gnuradio logran un mejor rendimiento que la teor\'ia, sobre todo el esquema DBPSK. Esto se debe a los diversos m\'etodos de
recuperaci\'on de la informaci\'on que emplean ambos algoritmos ya que constantemente han estado siendo optimizados por los
autores. Con esto se demuestra el rendimiento del c\'odigo fuente actual de \emph{GNURadio}.

%==========================================================================
\section{Espectrograma de la transmisi\'on}

\gnuradio contiene varias herramientas para visualizar las se\~nales que se transmiten y se reciben.
Estas herramientas son programas completos que se pueden utilizar como base para elaborar programas
m\'as complejos. Una de estas herramientas visuales es un espectrograma que permite ver la densidad
espectral de potencia de una se\~nal que se est\'a recibiendo. La compilaci\'on del c\'odigo fuente
instala este programa en \verb|/usr/bin/| para que se pueda acceder a ella de manera global. El
programa se llama \verb|usrp_fft.py| y se encuentra originalmente en la carpeta \verb|gr-utils| del
c\'odigo fuente. Este programa se puede acceder desde esa carpeta o bien desde su lugar global por medio de
la consola de comandos. El programa proporciona varios par\'ametros que permiten que se configure de
diferentes maneras dependiendo del uso que se le va dar. Estos par\'ametros son los siguientes:

\begin{itemize}
  \item \verb|-w|: Selecciona el USRP que se va a utilizar en caso de haber m\'as de uno conectado a
  la PC.
  \item \verb|-R|: Selecciona el lado RX que se va a utilizar en el USRP: Lado A o Lado B. Esto lo
  determina el lugar donde est\'e conectada la tarjeta auxiliar.
  \item \verb|-A|: Selecciona la antena que se va a utilizar. Esto solo se utiliza con las tarjetas
  de la serie RFX.
  \item \verb|-d|: Selecciona el valor de decimaci\'on con el que se configurar\'a el DDC del FPGA.
  Por defecto lo configura a 16.
  \item \verb|-f|: Especifica la frecuencia con la que se sintoniza la tarjeta auxiliar.
  \item \verb|-g|: Especifica la ganancia con la que se programa el amplificador programable. Los
  valores son en decibeles.
  \item \verb|-W|: Activa la opci\'on de utilizar el espectrograma. Por defecto la aplicaci\'on actua
  como un analizador de espectros, desplegando la FFT de la se\~nal recibida.
  \item \verb|-S|: Activa la opci\'on de utilizar el osciloscopio.
  \item \verb|--fft-size|: Especifica el tama\~no de muestras que utiliza la FFT. Por defecto
  utiliza 1024 muestras.
\end{itemize} 

Este programa se utiliz\'o durante la transmisi\'on de los datos generados por los programas
\verb|benchmark_tx.py| y \verb|benchmark_rx.py| para observar la densidad espectral de potencia de
la portadora. Las opciones que se utilizaron para configurar el programa fueron las siguientes:

\begin{center}
\verb|usrp_fft.py -f 30M -d 256 -W|
\end{center}

El espectrograma se muestra en la figura \ref{fig:spectrogramgui}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.7]{figs/spectrogramgui}
  \vspace{0.3in}
  \caption{Aplicaci\'on en \emph{Python} que muestra el espectrograma de lo que el USRP est\'a capturando.}
  \label{fig:spectrogramgui}
\end{figure}

El espectrograma consiste en una grafica de cascada (waterfall en Ingl\'es) que se despliega en
forma vertical (algunos autores la despliegan en forma horizontal). El eje Y es el tiempo medido en
segundos y la grafica se desplaza de abajo hacia arriba. El eje X representa el espectro en Hz. La
figura \ref{fig:spectrogramgui} muestra la intensidad de la portadora de 30Mhz centrada en la
grafica. Los colores tenues a un lado de la barra verde representan las bandas laterales de la
portadora. Desde esta aplicaci\'on es posible modificar varios par\'ametros del USRP como la
ganancia, la frecuencia y el valor de decimaci\'on del DDC. Los ejes tambi\'en se pueden ajustar por
medio de las opciones que aparecen en la derecha de la pantalla (Time Scale, Dyn Range, Ref Level).
En este ejemplo la portadora se puede apreciar claramente debido a la m\'inima cantidad de ruido ya que se
utiliz\'o un cable coaxial para la transmisi\'on, el cual introduce una cantidad despreciable de ruido.

%==========================================================================
\section{Diagrama de ojo}

Para observar la calidad de la se\~nal antes de que sea demodulada se utiliz\'o el diagrama de
ojo. Esta herramienta permite ver las distorsiones que ocurren en la transmisi\'on y ayuda a
tomar mejores decisiones sobre el dise\~no del receptor. \gnuradio no contiene esta
herramienta aun por lo que se opt\'o por crear un programa en \emph{Python} que pueda realizar el diagrama en
base a muestras capturadas por el USRP.

La captura de datos se realiz\'o utilizando una de las herramientas de la carpeta \verb|gr-utils|
llamada \verb|usrp_rx_cfile.py|. Este programa acepta como par\'ametro principal el nombre que se le
asignar\'a al archivo que va a almacenar las muestras. Los dem\'as par\'ametros se utilizan para
configurar el DDC y sintonizar la tarjeta auxiliar a la frecuencia deseada. Los par\'ametros que
soporta el programa son los siguientes:

\begin{itemize}
  \item \textbf{-R}: Selecciona el lado del USRP que se va a utilizar: A o B.
  \item \textbf{-d}: Selecciona la tasa de decimaci\'on. El valor por defecto es 16.
  \item \textbf{-f}: Establece la frecuencia.
  \item \textbf{-g}: Establece la ganancia en dB.
  \item \textbf{-8}: Configura el USRP para que env\'ie muestras de 8 bits en lugar de 16 bits.
  \item \textbf{-s}: Configura el USRP para que env\'ie muestras de tipo \emph{short} entrelazadas
  en lugar de muestras complejas de tipo \emph{float}.
  \item \textbf{-N}: Establece la cantidad de muestras que se van a capturar. Por defecto es
  infinito.
\end{itemize}

El programa se configur\'o para que capture muestras a una frecuencia central de 30Mhz. El tipo de
muestras son n\'umeros complejos de tipo \emph{float} ya que por defecto es con el que trabaja el USRP.

El experimento consisti\'o en capturar muestras de tres transmisiones a diferentes valores de exceso
de ancho de banda ($\alpha$) para observar los efectos del filtro de coseno elevado en la se\~nal.
Los resultados se muestran en la figura \ref{fig:rrcsignals}.

%ContinuedFloat se usa para hacer que las figuras sean un solo grupo pero se exandan a diferentes paginas.
\begin{figure}[htp]
  \centering
  \subfloat[$\alpha=0.35$]{\label{fig:eye35}\includegraphics[scale=0.65]{figs/ojo35}}\\
  \subfloat[$\alpha=0.50$]{\label{fig:eye50}\includegraphics[scale=0.65]{figs/ojo50}}
\end{figure}

\begin{figure}[htp]
    \ContinuedFloat
    \centering
    \subfloat[$\alpha=0.75$]{\label{fig:eye75}\includegraphics[scale=0.65]{figs/ojo75}}
    \vspace{0.3in}
    \caption{Se\~nales QPSK con filtrado de coseno elevado a diferentes valores de $\alpha$.}
    \label{fig:rrcsignals}
\end{figure}

La figura \ref{fig:eye35} muestra que a menor $\alpha$ la se\~nal se distorsiona m\'as y esto causa mayores
dificultades para detectar los s\'imbolos correctamente pero tambien resulta en un filtro m\'as r\'apido y
sencillo de implementar debido a que su respuesta al impulso es m\'as corta. La figura
\ref{fig:eye75} muestra menos distorci\'on en la se\~nal a consecuencia de un filtro m\'as complicado de
procesar eficientemente. El uso de un mayor ancho de banda tambi\'en implica que se puede introducir m\'as
ruido en la etapa de captura de RF (front end) y por lo tanto es necesario considerar las
compensaciones entre el exceso de ancho de banda, la inmunidad contra el ruido, la complejidad de
la etapa de recuperaci\'on del reloj de s\'imbolos y la eficiencia de procesamiento por parte del CPU
\cite{lee}. El CPU Core 2 Duo que se utiliz\'o fue suficiente para procesar filtros con $\alpha$ de
0.75. Estos filtros son internamente implementados con una mezcla de lenguaje C y ensamblador utilizando
instrucciones como SSE (\emph{streaming SIMD extensions}) para incrementar la velocidad y eficiencia
de procesamiento.

El programa que genera el diagrama de ojo a partir de un archivo con muestras del USRP se muestra en
el listado \ref{ex:eyeprog}.

\begin{lstlisting}[float, label=ex:eyeprog, caption={Programa que genera el diagrama de ojo a partir
de muestras tomadas del USRP.}, breaklines=true]

import pylab as p
import scipy

samp_per_sym = 8
hfile = '/home/haysoos/Documents/Tesis/usrp_capture/target.dat'

def get_traces(d, num_traces, samp_per_sym):
    traces = []
    trace_len = samp_per_sym * 3
    for i in range(num_traces):
        start_ind = (samp_per_sym / 2) - 1 + (i + 3) * trace_len
        traces.append(d[start_ind:start_ind + trace_len + 1])
    return traces
    
iq = scipy.fromfile(hfile, dtype = scipy.complex64)

ichan = [c.real for c in iq]

traces = get_traces(ichan, 200, samp_per_sym)
p.figure()
p.hold(True)
for tr in traces:
    p.plot(tr, 'b-')

p.title('Diagrama de ojo   ' + r'$\alpha=0.75$')
p.xlabel('Tiempo')
p.ylabel('Amplitud')

p.show()
\end{lstlisting}

Una observaci\'on importante es que los valores de tipo \emph{float} en \emph{Python} equivalen al tipo
\emph{double} en C el cual puede variar dependiendo el CPU que se est\'e utilizando pero en casos
t\'ipicos la precisi\'on es de 64 bits: 1 bit para el signo, 11 para el exponente y 52 para la mantisa
\cite{python}. El USRP configurado con el \emph{source} o \emph{sink} que utiliza el prefijo ``c''
utiliza la constante \verb|gr_complex| la cual equivale en lenguaje C a \emph{float}. Este tipo de
dato es de 32 bits: 1 bit para el signo, 8 bits para el exponente y 23 bits para la mantisa. \emph{Python}
por defecto no tiene soporte para representar el tipo \emph{float} de C lo cual introduce errores en la
representaci\'on de las muestras del USRP. La biblioteca \emph{Numpy} y \emph{Scipy} de \emph{Python} encapsula
varias representaciones de n\'umeros flotantes \cite{scipy} lo cual es necesario utilizar la correcta
cuando se trabaja con muestras que genera el USRP de manera independiente de los programas de
\emph{GNURadio}. Cada muestra compleja que transmite o recibe el USRP es representado por dos
n\'umeros flotantes de 32 bits por lo que es necesario utilizar el tipo de dato \emph{complex64} como
se muestra en el listado \ref{ex:eyeprog}.

%Constelacion observada
%==========================================================================
\section{Constelaci\'on observada}

Para observar la constelaci\'on recibida se utiliz\'o la versi\'on que utiliza la biblioteca QT
del programa benchmark. El programa RX contiene dos versiones en el c\'odigo fuente, una que utiliza
la consola y otra que genera una interfaz de usuario para monitorear la se\~nal de manera gr\'afica.
Esta aplicaci\'on tambi\'en es un buen ejemplo para ilustrar el uso de los controles gr\'aficos de
\gnuradio que utilizan esta biblioteca. Su diferencia con los controles que utilizan la biblioteca
\emph{wxWidgets} es que el c\'odigo de los controles QT ya est\'a optimizado para realizar gr\'aficas
con la ayuda de la extensi\'on \emph{QWT} el cual es una biblioteca madura mientras que los
controles que utilizan \emph{wxWidgets} fueron creados desde cero por los autores de \gnuradio y no
est\'an optimizados en su totalidad. \emph{QWT} es necesario que se instale correctamente para
utilizar los controles de QT. La instalaci\'on se explica a detalle en el ap\'endice \ref{AppA}. Los
controles QT forman un solo bloque para uso en los grafos de \emph{GNURadio}. Este bloque se llama
\verb|qtgui.sink_c| para datos complejos y \verb|qtgui.sink_f| para datos de punto flotante. El
constructor de estos bloques tiene la forma descrita en el listado \ref{ex:qtguiconst}.

\begin{lstlisting}[float, label=ex:qtguiconst, caption={Constructor de los bloques qtgui\_sink\_x},
breaklines=true, language={[ISO]C++}]
qtgui_make_sink_X (int fftsize, int wintype, double fc=0, 
                   double bandwidth=1.0, const std::string &name="Spectrum Display",
                   bool plotfreq=true, bool plotwaterfall=true, bool plotwaterfall3d=true,
                   bool plottime=true, bool plotconst=true, bool use_openGL=true,
                   QWidget *parent=NULL)
\end{lstlisting}

Los par\'ametros del constructor se describen de la siguiente manera:

\begin{itemize}
  \item \textbf{fftsize}: Tama\~no inicial de la FFT.
  \item \textbf{wintype}: Tipo de ventana inicial para la FFT. Puede ser una de las siguientes
  constantes tomadas de la clase \verb|gr.firdes|:
  \begin{itemize}
    \item WIN\_BLACKMAN 
    \item WIN\_BLACKMAN\_hARRIS
    \item WIN\_HAMMING
    \item WIN\_HANN 
    \item WIN\_KAISER
  \end{itemize}
  \item \textbf{fc}: Frecuencia central para el eje X.
  \item \textbf{bandwidth}: Especifica el rango alrededor de la frecuencia central para el eje X.
  \item \textbf{name}: Especifica el t\'itulo del GUI.
  \item \textbf{plotfreq}: Despliega el analizador de espectros.
  \item \textbf{plotwaterfall}: Despliega el espectrograma.
  \item \textbf{plotwaterfall3d}: Despliega el espectrograma en 3D.
  \item \textbf{plottime}: Despliega el osciloscopio.
  \item \textbf{plotconst}: Despliega el diagrama de constelaci\'on.
  \item \textbf{use\_openGL}: Utiliza extensiones para acelerar el despliege de las gr\'aficas.
  \item \textbf{parent}: Especifica un objeto el cual se utiliza como ventana principal para
  desplegar los controles.
\end{itemize}

El programa RX que se utiliz\'o se llama \verb|benchmark_qt_rx.py|. Utiliza los mismos comandos que la
versi\'on de consola para su configuraci\'on pero tambi\'en agrega uno nuevo que es la opci\'on
\emph{-G}. Esta opci\'on habilita el GUI que consiste en una aplicaci\'on QT que muestra el rendimiento del receptor y que
permite modificar los par\'ametros del receptor como los del lazo de costas y el sincronizador M\&M. Si no se utiliza la opci\'on
\emph{-G} el programa se comportar\'a igual que la versi\'on de consola.

Todos los programas \verb|benchmark_xx.py| tienen la opci\'on \emph{--from-file} que especifica que
los datos que se van a transmitir vienen de un archivo binario. Si esta opci\'on no se especifica
entonces el programa por defecto transmite los 8 bits menos significativos del n\'umero de paquete
en una cadena de caracteres ASCII. El usuario es libre de modificar el ejemplo para transmitir
alg\'un otro tipo de secuencia.

El experimento inicial consisti\'o en transmitir la secuencia de n\'umeros de paquetes y
observar la constelaci\'on recibida. Utilizando los valores por defecto de los par\'ametros descritos en
el apartado \ref{sec:params} y anexando la opci\'on \emph{-G} se ejecuto primeramente el programa
\verb|benchmark_qt_rx.py| y despues el programa \verb|benchmark_tx.py|. Los resultados obtenidos para una transmisi\'on con una
tasa de bits de 100kbits/s se mostran en la figura \ref{fig:dqpsktrans}.

\begin{figure}[htp]
  \centering
  \includegraphics[width=5.9in]{figs/dqpsktrans}
  \vspace{0.3in}
  \caption{Resultados de la transmisi\'on con par\'ametros por defecto del programa a 100kbits/s.}
  \label{fig:dqpsktrans}
\end{figure}

El GUI que muestra la figura \ref{fig:dqpsktrans} es una aplicaci\'on completa con la biblioteca QT.
El usuario puede modificar toda la interfaz a su gusto o bien generar una totalmente diferente aunque
esto requiere conocimientos de programaci\'on con esta biblioteca. Las aportaci\'ones de \gnuradio a
esta aplicaci\'on son los dos bloques QT que muestran los controles con las graficas. Los controles
de la izquierda muestran la se\~nal antes de ser demodulada en software, es decir, despu\'es de la
etapa DDC del USRP. Los controles de la derecha muestran la se\~nal despu\'es de la etapa de
demodulaci\'on. En la parte inferior se muestran algunas opciones para modificar los par\'ametros
del receptor como la decimaci\'on, la ganancia, y los par\'ametros del PLL y el sincronizador de
reloj de s\'imbolos.

Los valores por defecto que utiliza la aplicaci\'on \verb|benchmark_tx.py| y \\
\verb|benchmark_rx.py| no fueron eficientes para lograr una transmisi\'on satisfactoria. La figura
\ref{fig:dqpsktrans} muestra los puntos de la constelaci\'on muy esparcidos y forman nubes alrededor
del punto de convergencia por lo que la transmisi\'on mostraba una probabilidad de error muy alta.
Estos programas utilizan la primera versi\'on de la modulaci\'on DQPSK (lazo de costas y sincronizador
M\&M).

Los par\'ametros se ajustaron manualmente y se realizaron varias transmisiones hasta encontrar
los adecuados. Los par\'ametros y valores mencionados en el apartado \ref{sec:params} lograron una transmisi\'on exitosa dando
una recepci\'on de todos los paquetes enviados. La constelaci\'on que se logr\'o utilizando los par\'ametros del apartado
\ref{sec:params} se muestra en la figura \ref{fig:firstgoodconst}. Se puede observar que los s\'imbolos recibidos
convergen correctamente en los cuatro puntos de la constelaci\'on DQPSK.

\begin{figure}[htp]
  \centering
  \includegraphics[width=5.5in]{figs/firstgoodconst}
  \vspace{0.3in}
  \caption{Constelaci\'on obtenida con par\'ametros \'optimos de una transmisi\'on a 100kbits/s}
  \label{fig:firstgoodconst}
\end{figure}

Sin la opci\'on \emph{-G} el programa mostrar\'a su actividad en la consola. Este es el
comportamiento por defecto y es tambi\'en el comportamiento para los programas que no implementan el
GUI. La transmisi\'on de la figura \ref{fig:firstgoodconst} sin utilizar el GUI se muestra en la
figura \ref{fig:benchcli}.

\begin{figure}[htp]
  \centering
  \subfloat[Transmisor]{\label{fig:txcli}\includegraphics[width=5.5in]{figs/txcli}}\\
  \subfloat[Receptor]{\label{fig:rxcli}\includegraphics[width=5.5in]{figs/rxcli}}
  \vspace{0.5in}
  \caption{Programa \emph{benchmark} TX y RX en modo consola.}
  \label{fig:benchcli}
\end{figure}

El dise\~no original del programa muestra si los paquetes transmitidos son recibidos
correctamente pero no despliega el contenido de ellos. Cada l\'inea que muestra la figura
\ref{fig:rxcli} indica paquete se decodifico correctamente, el n\'umero del paquete decodificado, la
cantidad total de paquetes recibidos y la cantidad total de paquetes decodificados correctamente. La
figura \ref{fig:txcli} muestra la configuraci\'on del transmisor y los puntos en la parte
inferior emulan una barra de progreso indicando que el programa est\'a actualmente transmitiendo
informaci\'on al USRP.

Para demostrar el uso del bloque gr\'afico de QT en un programa de consola se modific\'o el programa
original para incluir este bloque dentro del grafo y poder observar la constelaci\'on sin tener que
desarrollar todo el GUI. La modificaci\'on se realiz\'o en el archivo \verb|usrp_receive_path2.py|
dentro del constructor de la clase \verb|usrp_receive_path| despu\'es de la etapa de configuraci\'on
del USRP y en el archivo principal \verb|benchmark_rx2.py| en la funci\'on \verb|main()|. Esta
modificaci\'on se muestra en el listado \ref{ex:qtsink}.

\begin{lstlisting}[float, label=ex:qtsink, caption={Modificaci\'on del programa \emph{benchmark} para
desplegar el bloque gr\'afico de QT.}, breaklines=true] 
class usrp_receive_path(gr.hier_block2):
    def __init__(self, demod_class, rx_callback, options):
        gr.hier_block2.__init__(self, "usrp_receive_path",
                gr.io_signature(0, 0, 0), # Entradas
                gr.io_signature(0, 0, 0)) # Salidas
        if options.rx_freq is None:
            sys.stderr.write("-f FREQ or --freq FREQ or --rx-freq FREQ must be specified\n")
            raise SystemExit

        #setup usrp
        self._demod_class = demod_class
        self._setup_usrp_source(options)

        rx_path = receive_path.receive_path(demod_class, rx_callback, options)
        for attr in dir(rx_path): #forward the methods
            if not attr.startswith('_') and not hasattr(self, attr):
                setattr(self, attr, getattr(rx_path, attr))

        #QT sink para monitorear la captura en el USRP.
        fftsize = 2048
        window = gr.firdes.WIN_BLACKMAN_hARRIS
        fc = 0
        bw = options.bitrate

        self.qapp = QtGui.QApplication(sys.argv)

        self.receiver = rx_path.packet_receiver._demodulator.phase_recov
        self.monitor = qtgui.sink_c(fftsize, window, fc, bw, "Monitor", True, False, False, False, True)
        #connect
        self.connect(self.u, rx_path)
        self.connect(self.receiver, self.monitor)

        self.pyobj = sip.wrapinstance(self.monitor.pyqwidget(), QtGui.QWidget)
        self.pyobj.show()
\end{lstlisting}

De acuerdo con la documentaci\'on de \emph{GNURadio}, para poder utilizar el bloque QT es necesario seguir
los siguientes pasos:
\begin{itemize}
  \item Crear un apuntador a una aplicaci\'on de QT. Para esto se utiliza la clase
  \verb|QApplication|.
  \item Crear el bloque sink de QT y conectarlo.
  \item Utilizar la utileria SIP (parte de los requerimientos de la instalaci\'on de QT) para
  convertir el apuntador del objeto C++ que representa el sink a un objeto \emph{Python}. Esto se hace con
  el fin de poder tener acceso directo a los m\'etodos del objeto desde \emph{Python}.
  \item Mandar llamar el m\'etodo \verb|show()| del objeto creado.
  \item Mandar llamar el m\'etodo \verb|start()| del bloque jer\'arquico en lugar del m\'etodo
  \verb|run()|. El m\'etodo \verb|start()| no causa la aplicaci\'on que se detenga hasta que el grafo
  termine de ejecutarse debido a que no manda llamar el m\'etodo \verb|wait()|.
  \item Mandar llamar el m\'etodo \verb|_exec()| del apuntador de la aplicaci\'on QT para poder desplegar
  los controles gr\'aficos. 
\end{itemize}

Para llegar a los bloques del grafo del demodulador DQPSK fue necesario pasar por varias capas
del c\'odigo hasta llegar al bloque que se va monitorear. Esto es debido al dise\~no modular del
programa. El bloque del demodulador que se monitore\'o fue el del sincronizador de fase (lazo de
costas) antes del decodificador diferencial. La conexi\'on se puede modificar para monitorear
cualquier parte del grafo.

\section{Transmisi\'on de un archivo}
Para transmitir datos de cualquier archivo es necesario utilizar la opci\'on \verb|--from-file| del programa \emph{benchmark}. El
programa no hace ninguna distinci\'on del tipo de archivo que se debe utilizar, para la aplicaci\'on lo que importa son los bits
contenidos en el archivo. Esto quiere decir que el archivo puede ser una imagen, un archivo de audio mp3, texto, etc. El programa
original puede realizar este tipo de transmisi\'on pero como se ilustr\'o en la figura \ref{fig:rxcli} solo despliega si el
paquete enviado se decodific\'o o no. Para poder escribir los datos del paquete a un archivo destino fue necesario modificar la
funci\'on que despliega las lineas en la consola del receptor.

Primeramente se inici\'o por crear un archivo nuevo cada que se ejecuta la funci\'on \verb|main()|
como se muestra en el listado \ref{ex:fileopen}.

\begin{lstlisting}[float, label=ex:fileopen, caption={C\'odigo anexo a la funci\'on main del
programa benchmark para abrir un nuevo archivo destino.}, breaklines=true]
def main():
    global n_rcvd, n_right, dest_file

    n_rcvd = 0
    n_right = 0

	#Codigo que se anexo
    dest_file = open('/home/jesus/workspace/Tesis/src/test.png', 'w')
\end{lstlisting}

El programa inicia creando un nuevo archivo en modo escritura como parte de la inicializaci\'on. La
segunda modificaci\'on se realiz\'o en la funci\'on \verb|rx_callback|. Esta funci\'on es
especial ya que el grafo es quien la ejecuta de manera autom\'atica cada vez que llega un
paquete. Su funci\'on es desplegar los resultados de la demodulaci\'on. La funci\'on recibe como
entrada dos par\'ametros: una bandera indicando si el paquete es v\'alido y la informaci\'on del
paquete. Por defecto el c\'odigo \'unicamente trabaja con la bandera y los dos primeros bytes del
paquete ya que ahi est\'a contenido el numero de paquete. El resto de los bytes contienen lo que se
transmiti\'o. Para poder escribir esta informaci\'on al archivo destino se anexo c\'odigo para que
escriba los bytes a partir del segundo en adelante al archivo que se inicializo. La modificaci\'on
se muestra en el listado \ref{ex:rxcallback}.

\begin{lstlisting}[float, label=ex:rxcallback, caption={Funci\'on que recive los datos demodulados y
los escribe a un archivo.}, breaklines=true]
def rx_callback(ok, payload):
   global n_rcvd, n_right
   (pktno,) = struct.unpack('!H', payload[0:2])
   n_rcvd += 1
   if ok:
      n_right += 1
      dest_file.write(payload[2:]) #Codigo que se anexo
   else:
      print 'Paquete descartado', payload[2:]

      print "ok = %5s  pktno = %4d  n_rcvd = %4d  n_right = %4d" % (
          ok, pktno, n_rcvd, n_right)

\end{lstlisting}

Por \'ultimo se agreg\'o c\'odigo despues de la funci\'on \emph{main}, antes de que termine el programa, para que
cierre el arhivo destino y los datos no se pierdan. Esto se muestra en el listado
\ref{ex:closefile}.

\begin{lstlisting}[float, label=ex:closefile, caption={C\'odigo anexo al final del programa
\emph{benchmark} para cerrar el archivo destino.}, breaklines=true]
if __name__ == '__main__':
    global dest_file
    try:
        main()
        dest_file.flush() #Codigo anexo
        dest_file.close()
    except KeyboardInterrupt:
        dest_file.flush() #Codigo anexo
        dest_file.close()
        pass

\end{lstlisting}

Durante el experimento se observ\'o que el \'ultimo paquete nunca llegaba por lo cual la transmisi\'on
siempre se estaba cortando. Esto fue debido a que el transmisor se cierra completamente cuando envia
el \'ultimo paquete al USRP. Este \'ultimo paquete se queda en el USRP y no se logra transmitir ya que
el control del dispositivo se perdi\'o. Para corregir este comportamiento fue necesario realizar un
cambio al c\'odigo del transmisor para que no se cierre. Este cambio se muestra en el listado
\ref{ex:txfix}.

\begin{lstlisting}[float, label=ex:txfix, caption={Correcci\'on al c\'odigo TX para enviar el
\'ultimo paquete.}, breaklines=true]
    while n < nbytes:
        if options.from_file is None:
            data = (pkt_size - 2) * chr(pktno & 0xff) 
        else:
            data = source_file.read(pkt_size - 2)
            if data == '':
                break;

        payload = struct.pack('!H', pktno & 0xffff) + data
        send_pkt(payload)
        n += len(payload)
        sys.stderr.write('.')
        if options.discontinuous and pktno % 5 == 4:
            time.sleep(1)
        pktno += 1
        
    #send_pkt(eof=True) #No enviar mensaje de EOF

    tb.wait()                 
\end{lstlisting}

La modificaci\'on consisti\'o en comentar la l\'inea que env\'ia el mensaje EOF (End Of File) al
grafo. Este mensaje causa que todos los bloques terminen su ejecuci\'on despu\'es de terminar de
procesar el \'ultimo byte que se encuentra en sus entradas. Esta modificaci\'on tiene el efecto de
que el grafo nunca terminar\'a de ejecutarse aun despu\'es de haber enviado todos los datos al USRP.
El usuario tiene que cerrar el programa manualmente.

Una observaci\'on importante es que los programas est\'an dise\~nados como ejemplos ilustrativos de
las capacidades de \gnuradio y por esta raz\'on no ofrecen alguna manera de saber si el paquete
logro llegar o no. Si un paquete no llega bien el archivo no podr\'a escribirse correctamente. Esto
se observ\'o en la imagen que se transmiti\'o al observar que el archivo estaba corrompido
despues de que termino la transmisi\'on debido a que algunos paquetes no llegaban. La
constelaci\'on observada de esta transmisi\'on a 30kbits/s se muestra en la figura \ref{fig:fileconst}.
Esta velocidad se utiliz\'o para lograr una transmisi\'on confiable y poder observar la imagen
correctamente. Tambi\'en permiti\'o utilizar los valores por defecto de los filtros polif\'asicos
ya que a velocidades m\'as altas es necesario optimizarlos.

\begin{figure}[htp]
  \centering
  \includegraphics[width=5.8in]{figs/fileconst}
  \vspace{0.3in}
  \caption{Constelaci\'on observada al transmitir un archivo a 30kbit/s.}
  \label{fig:fileconst}
\end{figure}
